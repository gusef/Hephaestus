
#' @title BOR_colors
#' 
#' @description Returns an array with our standard BOR colors
#' 
#' @export
#' 
BOR_colors <- function(){
  COLOR_SCHEME <- c('#2ca25f','#99d8c9','#ffeda0','#feb24c','#e34a33','#636363')
  names(COLOR_SCHEME) <- c('CR','PR','SD','NCRNPD','PD','UNK')   
  return(COLOR_SCHEME)
}

#' @title BOR_boxplot
#' 
#' @description Standard boxplot that splits a marker by BOR levels, makes boxplots and calculates a p-value
#' 
#' @param marker vector with a numeric marker value, eg. gene expression or signature expression
#' @param bor vector with BOR values (CR, PR, SD. NCRNPD, PD, UNK)
#' @param label Label used in the title
#' @param ylab (Default: value that is used for label) y axis label
#' @param title Title of the plot can be specified or is automatically derived from the y label.
#' @param jitter_method (Default: jitter) Stripchart overlay of the boxplots. Can also be overplot and stack
#' @param calculate_p_value (Default: TRUE) Should a Wilcoxon p-value between CR/PR vs. PD be calculated?
#' @param COLOR_SCHEME (Default: BOR_colors()) Names BOR color array
#' @param overlay_dot_col (Default: "#444444") Stripchart color
#' @param legend_pos (Default: 'topright') Position of the legend
#' @param legend_cex (Defaul: 0.7) cex of the legend text
#' @param cex font_sizes
#' @param ylim ylim
#' @param resp_classes (Default: c('CR','PR')) When calculating a p-value two groups need to be compared. Depending on the context only CR, CR/PR or even CR/PR/SD are used as responders.
#' @param non_resp_classes (Default: c('PD','UNK')) When calculating a p-value two groups need to be compared. Depending on the context different groups are used as non-responders
#
#' @export
#' 
#' @importFrom graphics boxplot
#' @importFrom graphics legend
#' @importFrom graphics mtext
#' @importFrom graphics stripchart
#' @importFrom stats wilcox.test
#' 
BOR_boxplot <- function(marker, 
                        bor, 
                        label, 
                        ylab = NA,
                        title = paste(label,'by BOR'),
                        jitter_method = 'jitter',
                        calculate_p_value = T,
                        COLOR_SCHEME = BOR_colors(),
                        overlay_dot_col = "#444444",
                        legend_pos = 'topright',
                        legend_cex = 0.7,
                        cex = 1,
                        ylim = NULL,
                        resp_classes = c('CR','PR'),
                        non_resp_classes = c('PD','UNK')){
  
  if (is.na(ylab)){
    ylab <- label
  }
  
  #reduce the color spectrum to the classes we have
  COLOR_SCHEME <- COLOR_SCHEME[names(COLOR_SCHEME) %in% levels(as.factor(bor))]
  
  #split the feature by the BOR levels
  sample_list <- lapply(names(COLOR_SCHEME),
                        function(x,marker,bor) marker[bor==x],
                        marker,
                        bor)
  names(sample_list) <- names(COLOR_SCHEME)
  
  #generate a boxplot
  boxplot(sample_list,
          col=COLOR_SCHEME,
          ylab=ylab,
          main=title,
          cex.lab = cex,
          cex.main = cex,
          cex.sub = cex,
          cex.axis = cex,
          outpch = '',
          ylim = ylim)
  
  if (calculate_p_value){
    #use only groups that have values
    resp <- unlist(sample_list[names(sample_list) %in% resp_classes])
    non_resp <- unlist(sample_list[names(sample_list) %in% non_resp_classes])
    
    if (length(resp) > 0 && length(non_resp) > 0){
      mtext(paste0('p-value (',
                   paste(resp_classes, collapse='/'),
                   ' vs. ',
                   paste(non_resp_classes, collapse='/'),
                   '):',
                   format(wilcox.test(resp, non_resp)$p.value,
                          digits=3)),
            3, cex=cex)
    }
  }
  
  #add dots on top of the barplot
  stripchart(sample_list, 
             method = jitter_method,
             vertical = TRUE, 
             pch = 21, 
             col = "black", 
             bg = overlay_dot_col, 
             add = TRUE) 
  legend(legend_pos,
         names(COLOR_SCHEME),
         col = COLOR_SCHEME,
         pch = 16,
         title = 'BOR',
         cex = legend_cex)
}


#' @title FC_boxplot
#' 
#' @description Fold-change boxplot that connects the same subject and shows trends this way
#' 
#' @param se Standard summarized experiment generated by MrClean
#' @param mat Feature matrix that has the same order as the SE (either gene expression or pathway scores)
#' @param marker Feature that is one row in the feature matrix
#' @param visit_cov Covariate in the SE that specifies the VISIT (default: screening)
#' @param screening_level Level in the visit_cov that specifies screening. All non-screening samples are labeled on-treatment (default: SCREENING)
#' @param cohort_cov If there are multiple cohorts there will a pair of boxes will be drawn for each. cohort_cov specifies the covariate in the SE that contains the cohort information (default: NA) in which case only one pair of boxes will be drawn.
#' @param subjectid Covariate in the SE that contains the subject ID (default: USUBJID)
#' @param ylab Y label of the boxplot - by default this is equal to marker
#' @param title Title of the boxplot
#' 
#' @export
#' 
#' @importFrom graphics boxplot
#' @importFrom graphics stripchart
#' @importFrom graphics abline
#' @importFrom graphics par
#' @importFrom graphics rect
#' @importFrom graphics segments
#' 
FC_boxplot <- function(se, 
                       mat, 
                       marker, 
                       visit_cov = 'screening', 
                       screening_level = 'SCREENING',
                       cohort_cov = NA,
                       subjectid = 'USUBJID',
                       ylab = marker,
                       title = 'Fold-Change boxplots',
                       ylim = NULL){
  
  if (is.na(cohort_cov)){
    se$cohort <- ''
    se$cohort <- factor(se$cohort)
  } else { 
    se$cohort <- droplevels(factor(se[[cohort_cov]]))
  }
  
  
  se$VIS <- se[[visit_cov]]
  se$VIS[se$VIS != screening_level] <- 'ONT'
  se$VIS[se$VIS == screening_level] <- 'SCR'
  
  breakdown <- lapply(levels(se$cohort),
                      function(x,se,mat,marker,subjectid){
                        nams <- c('SCR','ONT')
                        mark <- lapply(nams,
                                       function(y,x,se,mat,marker,subjectid){
                                         subset <- se[,se$VIS == y & se$cohort == x]
                                         return(mat[marker,colnames(subset)[order(subset[[subjectid]])]])
                                       },
                                       x,se,mat,marker,subjectid)
                        names(mark) <- nams
                        return(mark)
                      },se, mat, marker, subjectid)
  names(breakdown) <- levels(se$cohort)
  bd <- unlist(breakdown, recursive = F)
  
  if (is.na(cohort_cov)){
    op <- par(cex.axis=0.8)
  } else {
    op <- par(mar=c(8,4,4,2), cex.axis=0.8)
  }
  
  boxplot(bd, 
          las=2,
          col=c('#EEEEEE','#999999'),
          ylab = ylab,
          main = title,
          outpch = '',
          ylim = ylim)
  
  #remove the middle segments
  add <- 0.05
  for (i in seq(length(breakdown))){
    rect((i * 2 ) - 1 + add, 
         min(unlist(bd)), 
         i * 2 - add, 
         max(unlist(bd)), 
         col = 'white',
         border = NA)
  }
  #add dots on top of the barplot
  stripchart(bd, 
             method = 'overplot',
             vertical = TRUE, 
             pch = 21, 
             col = "black", 
             bg = "#444444", 
             add = TRUE) 
  
  #connect the dots (assumes the ordering of the subjects is the same)
  for(iii in seq(length(breakdown))){
    xx <- breakdown[[iii]]
    for (ii in 1:length(xx[[1]])) {
      aa <- xx[[1]][ii]
      bb <- xx[[2]][ii]
      if (aa > bb){
        col <- '#253494'
      } else {
        col <- '#ef3b2c'  
      }
      segments((iii * 2) - 1, aa, (iii * 2), bb, col=col)      
    }
  }   
  par(op)
  return(breakdown)
}


#' @title scatter
#' 
#' @description Standard scatter plot with correlation test, legend and trendline
#' 
#' @param marker1 Biomarker to show on the x axis
#' @param marker2 Biomarker to show on the y axis
#' @param col color of the scatter, can be a single color or a factorial (default: '#444444')
#' @param annot_colors Named list of colors corresponding to the levels of the color factorial (default: NULL)
#' @param trendline Draw a trendline on the plot (default: T)
#' @param trendline_col Color of the trendline (default: '#3182bd')
#' @param add_correlation Add a correlation value and p value on top of the plot (default: T)
#' @param correlation Type of correlation to be used (default: 'spearman')
#' @param cex cex (default: 1.5)
#' @param cex.pt pch(default:  16)
#' @param xlab label of the X axis (default: 'x')
#' @param ylab label of the y axis (default: 'y')
#' @param main Header (default: NULL)
#' @param plot_legend Should a legend be drawn if there are multiple colors used? (Default: T)
#' @param legend_cex Text size in the legend (default: 0.8)
#' @param legend_pos Position of the legend (default: 'topright')
#' @param cex font_sizes
#' 
#' @export
#' 
#' @importFrom graphics plot
#' 
scatter <- function(marker1,
                    marker2,
                    col = '#444444',
                    annot_colors = NULL,
                    trendline = T,
                    trendline_col = '#3182bd',
                    add_correlation = T,
                    correlation = 'spearman',
                    cex.pt = 1.5,
                    pch = 16,
                    xlab = 'x',
                    ylab = 'y',
                    main = NULL,
                    plot_legend = T,
                    legend_cex = 0.8,
                    legend_pos = 'topright',
                    cex = 1, 
                    ylim = NULL,
                    xlim = NULL){
  
  if(!length(marker1) == length(marker2)){
    stop('The two provided markers do not have the same lenght.')
  }
  
  
  #color processing
  if (class(col) == 'factor'){
    if (length(col) != length(marker1)){
      stop('If the colors are provided as factor there needs to be one value per sample.')
    }
    if (is.null(annot_colors)){
      annot_colors <- brewer.pal(length(levels(col)), 'Set1')
      names(annot_colors) <- levels(col)
    } else {
      if (!all(levels(col) %in% names(annot_colors))){
        stop('If you provide custom colors make sure they are named and each factor level has a color assigned.')
      }
    }
    col <- annot_colors[match(col, names(annot_colors))]
  }
  
  #scatter
  df <- data.frame(x = marker1,
                   y = marker2,
                   col = col)
  #filter NA values
  df <- df[rowSums(is.na(df)) == 0,]
  plot(df$x,
       df$y,
       pch = pch,
       cex = cex.pt,
       col = as.character(df$col),
       xlab = xlab,
       ylab = ylab,
       main = main,
       cex.lab = cex,
       cex.main = cex,
       cex.sub = cex,
       cex.axis = cex,
       xlim = xlim,
       ylim = ylim)
  
  #add a simple linear trendline
  if (trendline){
    abline(lm(y ~ x, data = df), col=trendline_col)
  }
  
  #calculate correlation values
  if(add_correlation){
    suppressWarnings(
      mtext(paste(simpleCap(correlation), 'cor:', 
                  format(cor(df$x, 
                             df$y, 
                             method = correlation),
                         digits=3),
                  '(p-val:',
                  format(cor.test(df$x, 
                                  df$y, 
                                  method = correlation)$p.value,
                         digits=3),')'),cex = cex) 
    )
  }
  
  #add a legend
  if (plot_legend & length(col) > 1 & !is.null(annot_colors)){
    legend(legend_pos,
           col = annot_colors,
           pch = pch,
           names(annot_colors),
           cex = legend_cex)
  }
}


simpleCap <- function(x) {
  s <- strsplit(x, " ")[[1]]
  paste(toupper(substring(s, 1,1)), substring(s, 2),
        sep="", collapse=" ")
}

#' @title standard_boxp
#' 
#' @description Standard boxplot with Wilcoxon test
#' 
#' @param sample_list list of biomarker vectors to be plotted
#' @param col (Default: '#999999') Color of boxplot. Can also be a color vector
#' @param ylab (Default: 'y') y axis label
#' @param main Title of the plot (default: NULL)
#' @param wilcox (Default: TRUE) Should a Wilcoxon p-value be calculated?
#' @param jitter_method (Default: jitter) Stripchart overlay of the boxplots. Can also be overplot and stack
#' @param overlay_dot_col (Default: "#444444") Stripchart color
#' @param las (Default: 1) Label orientation
#' @param cex font_sizes
#' 
#' @export
#' 
#' @importFrom graphics boxplot
#' @importFrom graphics mtext
#' @importFrom graphics stripchart
#' @importFrom stats wilcox.test
#' 
standard_boxp <- function(sample_list,
                          col = '#999999',
                          ylab = 'y',
                          main = NULL,
                          wilcox = TRUE,
                          jitter_method = 'jitter',
                          overlay_dot_col = "#444444",
                          las = 1,
                          cex = 1,
                          cex.axis = 1,
                          cex.dot = 1,
                          ylim = NULL){
  boxplot(sample_list,
          col = col,
          ylab = ylab,
          las =las,
          main = main,
          cex.lab = cex,
          cex.main = cex,
          cex.sub = cex,
          cex.axis = cex.axis,
          outpch = '',
          ylim = ylim)
  
  if (length(sample_list) == 2 & wilcox){
    mtext(paste('Wilcoxon p-val:',
                format(wilcox.test(sample_list[[1]], 
                                   sample_list[[2]])$p.value,
                       digits=3)),
          3,cex=cex)
  }
  
  #add dots on top of the boxplot
  stripchart(sample_list, 
             method = jitter_method,
             vertical = TRUE, 
             pch = 21, 
             col = "black", 
             bg = overlay_dot_col, 
             cex = cex.dot,
             add = TRUE) 
}


#########################################################################
############################################################################
#############################################################################

#Standard survival

#' @title plot_KM_optimal
#' 
#' @description Finds an optimal cutpoint for a continuous marker
#'
#' @param stime Numeric vector indicating the survival time
#' @param events 0/1 vector, where 1 corresponds to death or progression 
#' @param marker continuous marker
#' @param palette color palette
#' @param time_measure (default: Days) y label that is used in the KM plot
#' @param time_label (default: PFS) type of survival
#' @param main (default: NULL) Title of the plot
#' @param conf.int confidence interval (default: F)
#' @param HiLoClasses (default: c('Low', 'High')) High and low class names
#' 
#' @export
#' 
#' @importFrom maxstat maxstat.test
#' @importFrom survival Surv
#' 
plot_KM_optimal <- function(stime, 
                            events, 
                            marker, 
                            palette = NULL,
                            time_measure = 'Days',
                            time_label = 'PFS',
                            main = NULL, 
                            conf.int = F,
                            HiLoClasses = c('Low', 'High'),
                            cex = 1){
  
  #generate the dataset for the KM
  df <- data.frame(time = Surv(stime, events),
                   marker=marker)
  mstat <- maxstat.test(time ~ marker, df,
                        smethod="LogRank",
                        pmethod='condMC')
  cutp <- mstat$estimate  
  
  #split the continuous marker by the cutpoint
  factor_marker <- as.factor(HiLoClasses[(marker > cutp) + 1])
  
  submain <- paste('Optimal cutpoint:',
                   format(mstat$estimate, digits=2),
                   '| p-value (condMC):',
                   format(mstat$p.value, digits = 3))
  
  p <- plot_KM(stime, 
               events, 
               factor_marker, 
               palette,
               time_measure, 
               time_label,
               main, 
               submain, 
               conf.int,
               cex)
  
  return(p)
}   


#' @title plot_KM
#' 
#' @description Plots a KM curve based on a continuous marker
#'
#' @param stime Numeric vector indicating the survival time
#' @param events 0/1 vector, where 1 corresponds to death or progression 
#' @param marker groups (factor)
#' @param palette color
#' @param time_measure (default: Days) y label that is used in the KM plot
#' @param time_label (default: PFS) type of survival
#' @param main (default: NULL) Title of the plot
#' @param submain subtitle of the plot 
#' @param conf.int confidence interval (default: F)
#' 
#' @export
#' 
#' @importFrom survival Surv
#' @importFrom survival survfit
#' @importFrom survminer ggsurvplot
#' 
plot_KM <- function(stime, 
                    events, 
                    marker, 
                    palette = NULL,
                    time_measure = 'Days', 
                    time_label = 'Progression free survival',
                    main = NULL, 
                    submain = NULL,
                    conf.int = F,
                    cex = 1){
  
  if (class(marker) != 'factor'){
    stop('Marker needs to be a factor.')
  }
  
  df <- data.frame(time = Surv(stime, events),
                   marker=marker)
  
  fit <- survfit(time ~ marker, data=df)
  
  # Visualize with survminer
  p <- ggsurvplot(fit, 
                  data = df, 
                  risk.table = TRUE,
                  conf.int = conf.int,
                  tables.y.text = F, 
                  palette = palette)
  
  #add the proper x/y labels
  p$plot$labels$x <- paste0('Time (', time_measure ,')')
  p$plot$labels$y <- time_label
  p$plot$theme$axis.title.x$size <- 12 * cex
  p$plot$theme$axis.title.y$size <- 12 * cex
  p$table$theme$plot.title$size <- 12 * cex
  p$table$theme$plot.title$hjust <- 0.5 * cex
  p$table$theme$axis.title.x$size <- 12 * cex
  p$table$theme$axis.title.y$size <- 12 * cex
  
  
  
  if (!is.null(main)){
    p$plot$labels$title <- main
    p$plot$theme$plot.title$hjust = 0.5
    p$plot$theme$plot.title$face = "bold"
  }
  
  p$plot$theme$plot.subtitle$size <- 10 * cex
  p$plot$theme$plot.subtitle$hjust <- 0.5
  
  if (!is.null(submain)){
    p$plot$labels$subtitle <- submain
  } else if (length(levels(marker)) > 1){
    
    cox <- coxph(time ~ marker, df)
    cox <- summary(cox)
    
    submain <- paste('Wald test p-value:', format(cox$waldtest[3], digits=3))
    
    if (length(levels(marker)) == 2){
      submain <- paste(submain, '| HR:', format(cox$coefficients[2], digits=3))
      
    }
    p$plot$labels$subtitle <- submain
    
  }
  return(p)
  
}


plot_KM2 <- function (stime, events, marker, palette = NULL, time_measure = "Days", 
                      time_label = "Progression free survival", main = NULL, submain = NULL, 
                      conf.int = F, cex = 1) {
  if (class(marker) != "factor") {
    stop("Marker needs to be a factor.")
  }
  df <- data.frame(time = Surv(stime, events), marker = marker)
  fit <- survfit(time ~ marker, data = df)
  p <- ggsurvplot(fit, data = df, risk.table = TRUE, conf.int = conf.int, 
                  tables.y.text = F, palette = palette)
  p$plot$labels$x <- paste0("Time (", time_measure, ")")
  p$plot$labels$y <- time_label
  p$plot$theme$axis.title.x$size <- 12 * cex
  p$plot$theme$axis.title.y$size <- 12 * cex
  p$table$theme$plot.title$size <- 12 * cex
  p$table$theme$plot.title$hjust <- 0.5 * cex
  p$table$theme$axis.title.x$size <- 12 * cex
  p$table$theme$axis.title.y$size <- 12 * cex
  if (!is.null(main)) {
    p$plot$labels$title <- main
    p$plot$theme$plot.title$hjust = 0.5
    p$plot$theme$plot.title$face = "bold"
  }
  p$plot$theme$plot.subtitle$size <- 10 * cex
  p$plot$theme$plot.subtitle$hjust <- 0.5
  if (!is.null(submain)) {
    p$plot$labels$subtitle <- submain
  }
  else if (length(levels(marker)) > 1) {
    cox <- coxph(time ~ marker, df)
    cox <- summary(cox)
    submain <- paste0('HR: ', 
                      format(cox$conf.int[2],digits = 3), 
                      ' (95% CI: ',  
                      format(1/cox$conf.int[4], digits = 3),
                      '-',
                      format(1/cox$conf.int[3], digits = 3), ')')
    p$plot$labels$subtitle <- submain
  }
  return(p)
}


###################################################################################
######################################################################################
########################################################################################

## projection
#' @title project_pathway_space
#' 
#' @description
#' Takes a gene expression matrix and projects it into pathway space
#'
#' @param mat gene expression matrix with ncol samples and nrow genes
#' @param gene_sets list of gene set vectors
#' @param method (default: means) currently only means and 'geometric_means' is implemented
#' 
#' @return Projected pathway x samples matrix
#' 
#' @export
#' 
project_pathway_space <- function(mat, gene_sets, method = 'means'){
  
  stopifnot(method %in% c('means', 'geometric_means'))
  gene_sets <- lapply(gene_sets, function(x,y)x[x%in%y],rownames(mat))
  gene_sets <- gene_sets[sapply(gene_sets,length) > 2]
  
  if (method == 'means'){
    mean_set <- t(sapply(gene_sets, 
                         function(gs,exp)
                           colMeans(exp[gs,]),
                         mat))
  } else if(method == 'geometric_means'){
    mean_set <- t(sapply(gene_sets, 
                         function(gs,exp)
                           apply(exp[gs,], 2, geoMean),
                         mat))
  }
  
  return(mean_set)
}

geoMean <- function(x, Add = 1, ...) {
  exp(mean(log(x + Add), ...)) - Add
}


########################################################################################
###########################################################################################################
#############################################################################################

#rank by wilcoxon
#' @title rank_by_wilcoxon
#' 
#' @description takes a matrix of features by samples, splits samples by a group designation and does a wilcoxon test for each measurement. Returns a table of features ranked by p-value.
#' 
#' @param mat matrix of features x samples
#' @param group identify the sample groups that should be compared
#'
#' @export
#' 
#' @importFrom stats wilcox.test
#' @importFrom stats p.adjust
#' 
rank_by_wilcoxon <- function (mat, group) {
  # check that there are 2 groups to compare
  group <- factor(group)
  stopifnot(length(levels(group)) == 2)
  
  tests <- sapply(rownames(mat), 
                  function(marker, mat, group) {
                    # check that the marker is not all NAs
                    if(all(is.na(mat[marker,]))){
                      stop(paste(marker, 'needs to be filtered from matrix, all data is NA'))
                    }
                    
                    df <- data.frame(group = group, 
                                     marker = mat[marker,])
                    groups <- list(outcome1 = df$marker[df$group == levels(df$group)[1]], 
                                   outcome2 = df$marker[df$group == levels(df$group)[2]])
                    stat <- suppressWarnings(wilcox.test(groups$outcome1,
                                                         groups$outcome2))
                    
                    #count samples in each group (helpful if this data type has a lot of NAs)
                    samples1 <- sum(!is.na(groups$outcome1))
                    samples2 <- sum(!is.na(groups$outcome2))
                    
                    # fold change of means (group 1 / group 2)
                    means <- mean(groups$outcome1, na.rm = T)/ mean(groups$outcome2, na.rm = T)
                    res <- c(samples1, samples2, stat$statistic, means, stat$p.value)
                    names(res) <- c("samples1", "samples2", "W_stat",  "FC", "p.val")
                    return(res)
                  }, mat, group)
  df <- data.frame(t(tests))
  df$fdr <- p.adjust(df$p.val, method = "BH")
  df <- df[order(df$p.val), ]
  return(df)
}


######################################################################################
#######################################################################################
#tabify



#' @title tabify
#' 
#' @description Function that takes two factorials, generates a table breakdown and calculates percentages
#' 
#' @param factor1 Factorial
#' @param factor2 Factorial
#' @param by_row (default: F) Should the percentage calculated by row or by column
#' 
#' @export
#' 
tabify <- function(factor1, factor2, by_row = F){
  if (by_row){
    summarize <- rowSums 
    mar <- 1
  } else {
    summarize <- colSums   
    mar <- 2
  }
  
  tab <- table(factor1, factor2)
  tab_per <- round(sweep(tab, mar, summarize(tab),'/') * 100, digits=1)
  
  tab <- sapply(colnames(tab), 
                function(x, tab, tab_per)
                  paste0(tab[,x],' (',tab_per[,x],'%)'),
                tab, tab_per)
  rownames(tab) <- rownames(tab_per)
  return(tab)
}

